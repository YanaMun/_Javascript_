**Алгоритм RLE (Run-Length Encoding)** — простой алгоритм сжатия данных, который заменяет повторяющиеся символы (серии) на один символ и число его повторов.
# Как работает данный алгоритм
## Сжатие данных (code):
Алгоритм RLE, проходя по строке, ищет повторяющиеся символы и заменяет их на спец символ, количество его повторений и символ, который повторяется.

**Например**, строка `aaaabbccccc` будет преобразована в `#4abb#5c`
## Распаковка данных (decode):
Алгоритм RLE прочитывает спец символ, после которого написано количество повторов и символ, который повторяется, и восстанавливает исходную последовательность.

**Например**, строка `#4abb#5c` будет преобразована в `aaaabbccccc`
### Примеры из input.txt
- Обычный пример с небольшим количеством повторяющихся символов (**input.txt**)
- Пример, где повторяющийся символ является специальным символом (#) (**input1.txt**)
- Пример, с количеством повторяющихся символов больше, чем 255 (**input2.txt**)

# Использование:
Вы можете запустить скрипт из командной строки. Скрипт принимает четыре аргумента:
1. Операция (code или decode).
2. Путь к входному файлу, содержащий текст, подлежащий обработке.
3. Путь к выходному файлу, в который будет сохранен результат.

`node rle.js <operation> <inputFile> <outputFile>`

## Функция rle_code (Кодирование строки)
На вход принимается строка.

Создаём переменную `result` - после выполнения функции здеcь будет храниться закодированная строка.
```javascript
let result = '';
let i = 0;
```

Далее подсчитываем количество повторений текущего (i-того) символа.

Если число повторений меньше 3, то повторяем символ указанное количество раз через метод `repeat()`.

Иначе записываем через `# + число повторений + текущий символ`
```javascript
while (i < input.length) {
        let currentSymbol = input[i];
        let count = 1;

        while (currentSymbol === input[i + count]) {
            count++;
        }

        if (count <= 3) { 
            result += currentSymbol.repeat(count);
        } else {
            result += `#${count}${currentSymbol}`; 
        }
        i += count;
    }
```

## Функция rle_decode (Декодирование строки)
На вход принимается строка.

Создаём переменную `result` - после выполнения функции здеcь будет храниться декодированная строка.
```javascript
let result = '';
let i = 0;
```

Далее ищем спецсимвол #,после которого читаем число повторений и символ, который повторяется.
Учитываем тот случай, когда символ, который повторяется может быть тоже #.
Повторяем текущий символ указанное число раз через метод `repeat()`.
Если встретился обычный символ без спецсимвола, то добавляем его как есть.
```javascript
while (i < input.length) {
        if (input[i] === '#') {
            i++; 
            let count = '';
            while (!isNaN(input[i]) && i < input.length) { 
                count += input[i];
                i++;
            }
            if (input[i] === '#') { 
                result += '#'.repeat(Number(count)); 
            } else {
                result += input[i].repeat(Number(count)); 
            }
        } else {
            result += input[i]; 
        }
        i++;
    }
```

# Основной код.
Получаем доступ к аргументам командной строки через глобальный объект `process.argv` и задаем остальным элементам дополнительные аргументы командной строки, а именно:
1. Операция
2. Путь к входному файлу.
3. Путь к выходному файлу.
```javascript
const args = process.argv;
const op = args[2];
const inputFile = args[3];
const outputFile = args[4];
```
Далее инициализируем переменную `inText`, которая из входного файла будет считывать строку.
В зависимости от операции, скрипт будет выполнять нужную функцию. После выполнения которой подсчитывается Степень сжатия и выводится в консоль.
```javascript
if (op === 'code') {
    res = rle_encode(inText);
    console.log("Compression ratio = ", inText.length / res.length); // Степень сжатия
} else if (op === 'decode') {
    res = rle_decode(inText);
    console.log("Compression ratio = ", res.length / inText.length);
}
```

Результат скрипта записывается в выходной файл.
